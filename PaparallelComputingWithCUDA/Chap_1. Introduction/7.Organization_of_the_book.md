# 7. Cấu trúc cuốn sách này

Cuốn sách này được tổ chức thành bốn phần. Phần I trình bày các khái niệm cơ bản trong lập trình song song, song song dữ liệu, GPU và tối ưu hóa hiệu năng. Các chương nền tảng này trang bị cho người đọc kiến thức và kỹ năng cơ bản cần thiết để trở thành lập trình viên GPU. Phần II trình bày các mô hình song song nguyên thủy, và Phần III trình bày các mô hình song song nâng cao hơn và các ứng dụng. Hai phần này áp dụng kiến thức và kỹ năng đã được học ở phần đầu tiên và giới thiệu các tính năng kiến trúc GPU và kỹ thuật tối ưu hóa khác khi cần thiết. Phần cuối cùng, Phần IV, giới thiệu các thực hành nâng cao để hoàn thiện kiến thức của những người đọc muốn trở thành lập trình viên GPU chuyên gia.

Phần I về các khái niệm cơ bản bao gồm các Chương 2 đến 6. Chương 2, Tính toán song song dữ liệu không đồng nhất, giới thiệu về song song dữ liệu và lập trình CUDA C. Chương này dựa trên giả định người đọc đã có kinh nghiệm lập trình C trước đó. Đầu tiên, chương giới thiệu CUDA C như một phần mở rộng đơn giản, nhỏ của C hỗ trợ tính toán dị cấu trúc CPU/GPU và mô hình lập trình song song đa dữ liệu, đơn chương trình được sử dụng rộng rãi. Sau đó, chương trình trình bày các quá trình tư duy liên quan đến (1) xác định phần của chương trình ứng dụng cần được song song hóa, (2) phân lập dữ liệu được sử dụng bởi mã song song hóa, sử dụng hàm API để cấp phát bộ nhớ trên thiết bị tính toán song song, (3) sử dụng hàm API để truyền dữ liệu đến thiết bị tính toán song song, (4) phát triển phần song song thành một hàm kernel sẽ được thực thi bởi các luồng song song, (5) khởi chạy hàm kernel để thực thi bởi các luồng song song, và (6) cuối cùng là truyền dữ liệu trở lại bộ xử lý chính bằng lệnh gọi hàm API. Chúng tôi sử dụng ví dụ về phép cộng vector để minh họa các khái niệm này. Mặc dù mục tiêu của Chương này là dạy đủ các khái niệm của mô hình lập trình CUDA C để người đọc có thể viết một chương trình CUDA C song song đơn giản, nhưng nó bao gồm một số kỹ năng cơ bản cần thiết để phát triển một ứng dụng song song dựa trên bất kỳ giao diện lập trình song song nào.

Chương 3, Lưới đa chiều và Dữ liệu, trình bày chi tiết hơn về mô hình thực thi song song của CUDA, đặc biệt là liên quan đến việc xử lý dữ liệu đa chiều bằng cách sử dụng tổ chức đa chiều của các luồng. Nó cung cấp đủ thông tin chi tiết về việc tạo, tổ chức, liên kết tài nguyên và liên kết dữ liệu của các luồng để cho phép người đọc triển khai phép tính phức tạp sử dụng CUDA C.

Chương 4, Kiến trúc và Lịch trình Tính toán, giới thiệu kiến trúc GPU, tập trung vào cách các nhân tính toán được tổ chức và cách các luồng được lập lịch trình để thực thi trên các nhân này. Các vấn đề về kiến trúc khác nhau được thảo luận, cùng với ảnh hưởng của chúng đến hiệu năng của mã được thực thi trên kiến trúc GPU. Điều này bao gồm các khái niệm như khả năng mở rộng minh bạch, thực thi SIMD và sự phân kỳ điều khiển, đa luồng và khả năng chịu độ trễ, và độ chiếm dụng, tất cả đều được định nghĩa và thảo luận trong chương này.

Chương 5, Kiến trúc Bộ nhớ và Tính cục bộ Dữ liệu, mở rộng Chương 4, Kiến trúc Tính toán và Lập lịch, bằng cách thảo luận về kiến trúc bộ nhớ của GPU. Chương này cũng thảo luận về các bộ nhớ đặc biệt có thể được sử dụng để lưu trữ các biến CUDA nhằm quản lý việc phân phối dữ liệu và cải thiện tốc độ thực thi chương trình. Chúng tôi giới thiệu các tính năng ngôn ngữ CUDA dùng để phân bổ và sử dụng các bộ nhớ này. Việc sử dụng thích hợp các bộ nhớ này có thể cải thiện đáng kể thông lượng truy cập dữ liệu và giúp giảm thiểu tắc nghẽn lưu lượng trong hệ thống bộ nhớ.

Chương 6, Những cân nhắc về hiệu năng, trình bày một số cân nhắc quan trọng về hiệu năng trong phần cứng CUDA hiện tại. Đặc biệt, chương này cung cấp thêm chi tiết về các mô hình thực thi luồng và truy cập bộ nhớ mong muốn. Những chi tiết này tạo thành cơ sở khái niệm cho lập trình viên để suy luận về hậu quả của các quyết định của họ trong việc tổ chức tính toán và dữ liệu. Chương kết thúc bằng một danh sách kiểm tra các chiến lược tối ưu hóa phổ biến mà lập trình viên GPU thường sử dụng để tối ưu hóa bất kỳ mô hình tính toán nào. Danh sách kiểm tra này sẽ được sử dụng xuyên suốt hai phần tiếp theo của sách để tối ưu hóa các mô hình song song và ứng dụng khác nhau.

Phần II về các mô hình song song nguyên thuỷ bao gồm các Chương 7 đến 12. Chương 7, Convolution (Hồi quy), trình bày về hồi quy, một mô hình tính toán song song thường được sử dụng, bắt nguồn từ xử lý tín hiệu số và thị giác máy tính, đòi hỏi phải quản lý cẩn thận tính cục bộ truy cập dữ liệu. Chúng ta cũng sử dụng mô hình này để giới thiệu bộ nhớ không đổi và bộ nhớ đệm trong các GPU hiện đại. Chương 8, Stencil (Mẫu), trình bày về mẫu, một mô hình tương tự như hồi quy nhưng bắt nguồn từ việc giải các phương trình vi phân và có những đặc điểm riêng biệt tạo ra các cơ hội tối ưu hoá truy cập dữ liệu độc đáo hơn nữa. Chúng ta cũng sử dụng mô hình này để giới thiệu tổ chức 3D của luồng và dữ liệu, và để giới thiệu một tối ưu hoá được đưa ra trong Chương 6, Cân nhắc về Hiệu năng, nhắm mục tiêu vào độ hạt của luồng.

Chương 9, Histogram song song, trình bày về histogram, một mô hình được sử dụng rộng rãi trong phân tích dữ liệu thống kê cũng như nhận dạng mẫu trong các tập dữ liệu lớn. Chúng ta cũng sử dụng mô hình này để giới thiệu các thao tác nguyên tử như một phương tiện để phối hợp các cập nhật đồng thời vào dữ liệu được chia sẻ và tối ưu hóa riêng tư, làm giảm chi phí của các thao tác này. Chương 10, Thu gọn và giảm thiểu sự phân kỳ, giới thiệu mô hình cây thu gọn, được sử dụng để tóm tắt một tập hợp dữ liệu đầu vào. Chúng ta cũng sử dụng mô hình này để chứng minh tác động của sự phân kỳ điều khiển đến hiệu năng và chỉ ra các kỹ thuật để giảm thiểu tác động này. Chương 11, Tổng tiền tố (Scan), trình bày tổng tiền tố, hay scan, một mô hình tính toán song song quan trọng chuyển đổi tính toán tuần tự vốn có thành tính toán song song. Chúng ta cũng sử dụng mô hình này để giới thiệu khái niệm hiệu quả công việc trong các thuật toán song song. Cuối cùng, Chương 12, Trộn, trình bày phép trộn song song, một mô hình được sử dụng rộng rãi trong các chiến lược phân chia công việc và hợp nhất. Chúng ta cũng sử dụng chương này để giới thiệu việc xác định và tổ chức dữ liệu đầu vào động.

Phần III về các mô hình song song nâng cao và ứng dụng có tinh thần tương tự như Phần II, nhưng các mô hình được đề cập phức tạp hơn và thường bao gồm nhiều ngữ cảnh ứng dụng hơn. Do đó, các chương này ít tập trung vào việc giới thiệu các kỹ thuật hoặc tính năng mới hơn và tập trung nhiều hơn vào các cân nhắc cụ thể của ứng dụng. Đối với mỗi ứng dụng, chúng ta bắt đầu bằng việc xác định các cách thức thay thế để xây dựng cấu trúc cơ bản của việc thực thi song song và tiếp tục với việc lập luận về ưu điểm và nhược điểm của mỗi cách thức thay thế. Sau đó, chúng ta sẽ đi qua các bước biến đổi mã cần thiết để đạt được hiệu năng cao. Các chương này giúp người đọc kết hợp tất cả các tài liệu từ các chương trước và hỗ trợ họ khi họ thực hiện các dự án phát triển ứng dụng của riêng mình.

Phần III bao gồm các Chương 13 đến 19. Chương 13, Sắp xếp, trình bày hai dạng sắp xếp song song: sắp xếp cơ số và sắp xếp trộn. Mô hình nâng cao này tận dụng các mô hình nguyên thủy hơn đã được đề cập trong các chương trước, đặc biệt là tổng tiền tố và trộn song song. Chương 14, Tính toán Ma trận Thưa, trình bày tính toán ma trận thưa, được sử dụng rộng rãi để xử lý các tập dữ liệu rất lớn. 1.7 Cấu trúc của sách 17 Chương này giới thiệu cho người đọc các khái niệm về việc sắp xếp lại dữ liệu để truy cập song song hiệu quả hơn: nén dữ liệu, bổ sung, sắp xếp, chuyển vị và chuẩn hóa. Chương 15, Duyệt Đồ thị, giới thiệu các thuật toán đồ thị và cách tìm kiếm đồ thị có thể được thực hiện hiệu quả trong lập trình GPU. Nhiều chiến lược khác nhau được trình bày để song song hóa các thuật toán đồ thị, và tác động của cấu trúc đồ thị đến việc lựa chọn thuật toán tốt nhất được thảo luận. Các chiến lược này dựa trên các mô hình nguyên thủy hơn, chẳng hạn như histogram và merge.

Chương 16, Học sâu, đề cập đến học sâu, một lĩnh vực đang trở nên vô cùng quan trọng đối với tính toán GPU. Chúng tôi giới thiệu việc triển khai hiệu quả mạng nơ-ron tích chập và để lại các thảo luận chuyên sâu hơn cho các nguồn khác. Việc triển khai hiệu quả mạng nơ-ron tích chập tận dụng các kỹ thuật như ghép ô và các mẫu như tích chập. Chương 17, Tái tạo ảnh cộng hưởng từ bằng phương pháp lặp, đề cập đến tái tạo MRI phi Descartes và cách tận dụng các kỹ thuật như hợp nhất vòng lặp và biến đổi phân tán-tập hợp để tăng cường tính song song và giảm chi phí đồng bộ hóa. Chương 18, Bản đồ thế năng tĩnh điện, đề cập đến trực quan hóa và phân tích phân tử, được hưởng lợi từ các kỹ thuật xử lý dữ liệu không đều bằng cách áp dụng những bài học kinh nghiệm từ tính toán ma trận thưa.

Chương 19, Lập trình song song và Tư duy tính toán, giới thiệu tư duy tính toán, nghệ thuật xây dựng và giải quyết các bài toán tính toán theo cách dễ dàng hơn cho HPC. Chương này làm điều đó bằng cách trình bày khái niệm tổ chức các tác vụ tính toán của một chương trình sao cho chúng có thể được thực hiện song song. Chúng ta bắt đầu bằng việc thảo luận về quá trình chuyển đổi việc tổ chức các khái niệm trừu tượng khoa học, đặc thù của bài toán thành các tác vụ tính toán, đây là bước đầu tiên quan trọng trong việc tạo ra phần mềm ứng dụng chất lượng cao, tuần tự hay song song. Sau đó, chương trình thảo luận về các cấu trúc thuật toán song song và ảnh hưởng của chúng đến hiệu năng ứng dụng, dựa trên kinh nghiệm tinh chỉnh hiệu năng với CUDA. Mặc dù chúng ta không đi sâu vào các chi tiết triển khai của các phong cách lập trình song song thay thế này, nhưng chúng tôi kỳ vọng rằng người đọc sẽ có thể học lập trình trong bất kỳ phong cách nào trong số đó với nền tảng mà họ có được trong cuốn sách này. Chúng tôi cũng trình bày một nghiên cứu điển hình cấp cao để cho thấy những cơ hội có thể nhìn thấy thông qua tư duy tính toán sáng tạo.

Phần IV về các kỹ thuật nâng cao gồm các Chương 20, 22. Chương 20, Lập trình cụm tính toán dị cấu trúc, trình bày lập trình CUDA trên các cụm dị cấu trúc, trong đó mỗi nút tính toán bao gồm cả CPU và GPU. Chúng ta thảo luận về việc sử dụng MPI cùng với CUDA để tích hợp cả tính toán liên nút và tính toán nội nút và các vấn đề cũng như kỹ thuật giao tiếp phát sinh. Chương 21, Song song động CUDA, trình bày song song động, đó là khả năng của GPU tự động tạo công việc dựa trên dữ liệu hoặc cấu trúc chương trình thay vì luôn phải chờ CPU thực hiện. Chương 22, Các kỹ thuật nâng cao và sự phát triển trong tương lai, trình bày một danh sách các tính năng và kỹ thuật nâng cao đa dạng mà lập trình viên CUDA cần biết. Chúng bao gồm các chủ đề như bộ nhớ zero-copy, bộ nhớ ảo hợp nhất, thực thi đồng thời nhiều kernel, gọi hàm, xử lý ngoại lệ, gỡ lỗi, phân tích hiệu năng, hỗ trợ độ chính xác kép, kích thước bộ nhớ cache/scratchpad cấu hình được, và các chủ đề khác. Ví dụ, các phiên bản CUDA ban đầu chỉ cung cấp khả năng sử dụng bộ nhớ chia sẻ hạn chế giữa CPU và GPU. Lập trình viên cần phải quản lý rõ ràng việc truyền dữ liệu giữa CPU và GPU. Tuy nhiên, các phiên bản CUDA hiện tại hỗ trợ các tính năng như bộ nhớ ảo hợp nhất và bộ nhớ zero-copy cho phép chia sẻ dữ liệu liền mạch giữa CPU và GPU. Với sự hỗ trợ đó, lập trình viên CUDA có thể khai báo biến và cấu trúc dữ liệu được chia sẻ giữa CPU và GPU. Phần cứng và phần mềm thời gian chạy duy trì tính nhất quán và tự động thực hiện các hoạt động truyền dữ liệu được tối ưu hóa thay cho lập trình viên khi cần thiết. Sự hỗ trợ này làm giảm đáng kể độ phức tạp của lập trình liên quan đến việc chồng chéo truyền dữ liệu với các hoạt động tính toán và I/O. Trong phần giới thiệu của sách giáo khoa, chúng tôi sử dụng các API để truyền dữ liệu rõ ràng để người đọc hiểu rõ hơn về những gì xảy ra bên trong. Sau đó, chúng tôi giới thiệu bộ nhớ ảo hợp nhất và bộ nhớ zero-copy trong Chương 22, Các kỹ thuật nâng cao và sự phát triển trong tương lai.

Mặc dù các chương trong cuốn sách này dựa trên CUDA, chúng giúp người đọc xây dựng nền tảng cho lập trình song song nói chung. Chúng tôi tin rằng con người hiểu tốt nhất khi học từ những ví dụ cụ thể. Có nghĩa là, trước tiên chúng ta phải học các khái niệm trong ngữ cảnh của một mô hình lập trình cụ thể, điều này cung cấp cho chúng ta nền tảng vững chắc khi khái quát kiến thức của mình sang các mô hình lập trình khác. Khi làm như vậy, chúng ta có thể dựa trên kinh nghiệm cụ thể của mình từ các ví dụ CUDA. Kinh nghiệm sâu rộng về CUDA cũng giúp chúng ta đạt được sự trưởng thành, điều này sẽ giúp chúng ta học được các khái niệm thậm chí có thể không liên quan đến mô hình CUDA.

Chương 23, Kết luận và Triển vọng, trình bày những nhận xét cuối cùng và triển vọng cho tương lai của lập trình song song siêu lớn. Đầu tiên, chúng ta sẽ xem lại các mục tiêu của mình và tóm tắt cách các chương kết hợp với nhau để giúp đạt được các mục tiêu đó. Sau đó, chúng ta kết luận với dự đoán rằng những tiến bộ nhanh chóng trong điện toán song song siêu lớn sẽ làm cho nó trở thành một trong những lĩnh vực thú vị nhất trong thập kỷ tới.
